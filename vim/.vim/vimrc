set termguicolors
colorscheme one

" Nvim defaults
" --------------
set background=dark

" Backspace should be able to remove the text inserted before
set backspace=indent,eol,start

" Visual autocomplete for command menu
set wildmenu
" Display incomplete commands
set showcmd

" Search as characters are entered
set incsearch
" Always show the status line at the bottom, even if you only have one window open
set laststatus=2
" Disable audible bell because it's annoying
set noerrorbells visualbell t_vb= 	 

" Read if a file was changed outside of Vim
set autoread

" Tabs and indentation
set autoindent
set tabstop=4 shiftwidth=4
set expandtab smarttab

set noswapfile
set number
set noemoji
set nowrap
" search is case-insensitive, until a capital letter is added
set ignorecase smartcase
set scrolloff=8

set lazyredraw
" Delete comment character when joining commented lines
set formatoptions+=j


set splitright splitbelow
" Allow scrolling, resizing and clicking with mouse
set mouse=a

set timeout timeoutlen=3000 ttimeoutlen=100

" Allow local .vimrc per directory
set exrc

" Vinegar, don't show dotfiles on start. Toggle with 'gh'
let g:netrw_list_hide = '\(^\|\s\s\)\zs\.\S\+'
" Allow to move files to another (say, parent) directory
let g:netrw_keepdir = 0

augroup Netrw
    autocmd!
    autocmd FileType netrw setlocal bufhidden=wipe
augroup END

" Different cursors for Insert and Normal modes
let &t_SI = "\<Esc>]50;CursorShape=1\x7"
let &t_SR = "\<Esc>]50;CursorShape=2\x7"
let &t_EI = "\<Esc>]50;CursorShape=0\x7"

let mapleader = " "
nnoremap <leader>qq :bd<CR>
nnoremap <leader>vc :vs ~/.vim/vimrc<CR>
nnoremap <leader>zc :vs ~/.zshrc<CR>

augroup RC
    autocmd!
    autocmd BufWritePost vimrc source %
augroup END


" UNDOTREE
" ---- --
set undodir=~/.vim/undodir
set undofile
nnoremap <leader>u :UndotreeToggle<CR>


" FUGITIVE
" ---- --
nnoremap <leader>gc :Gdiffsplit<CR>
nnoremap <leader>gf :diffget //2<CR>
nnoremap <leader>gj :diffget //3<CR>
" Fix git hooks output for husky
let g:fugitive_pty = 0

" COMMENTARY
" ---- --
augroup Commentary
    autocmd!
    autocmd FileType c,typescript,javascript,typescriptreact,hocon setlocal commentstring=//\ %s
    autocmd FileType markdown setlocal commentstring=<!--\ %s\ -->
augroup END


" FZF / Ripgrep
" ---- --
set runtimepath+=/usr/local/opt/fzf
nnoremap <leader>f :GFiles<CR>
nnoremap <leader>b :Buffers<CR>
nnoremap \ :Rg<CR>
" Allow passing optional flags into Rg
"	Example: :Rg myterm -g '*.md'
" command! -bang -nargs=* Rg call fzf#vim#grep("rg --column --line-number --no-heading --color=always --smart-case " . <q-args>, 1, <bang>0)
command! -bang -nargs=* Rg
  \ call fzf#vim#grep(
  \   'rg --column --line-number --hidden --ignore-case --no-heading --color=always '.shellescape(<q-args>), 1,
  \   <bang>0 ? fzf#vim#with_preview({'options': '--delimiter : --nth 4..'}, 'up:60%')
  \           : fzf#vim#with_preview({'options': '--delimiter : --nth 4..'}, 'right:50%', '?'),
  \   <bang>0)

" Customize fzf colors to match your color scheme
" - fzf#wrap translates this to a set of `--color` options
let g:fzf_colors =
\ { 'fg':      ['fg', 'Normal'],
  \ 'bg':      ['bg', 'Normal'],
  \ 'hl':      ['fg', 'Comment'],
  \ 'fg+':     ['fg', 'CursorLine', 'CursorColumn', 'Normal'],
  \ 'bg+':     ['bg', 'CursorLine', 'CursorColumn'],
  \ 'hl+':     ['fg', 'Statement'],
  \ 'info':    ['fg', 'PreProc'],
  \ 'border':  ['fg', 'Ignore'],
  \ 'prompt':  ['fg', 'Conditional'],
  \ 'pointer': ['fg', 'Exception'],
  \ 'marker':  ['fg', 'Keyword'],
  \ 'spinner': ['fg', 'Label'],
  \ 'header':  ['fg', 'Comment'] }

" Vim Wiki
" ---- --
let g:vimwiki_list = [{'path': '~/.wiki/'}]
let g:vimwiki_global_ext = 0
let g:vimwiki_folding = 'custom'


" Test
nnoremap <leader>t :w<CR> :TestFile<CR>
let test#strategy = 'vimterminal'
let test#java#runner = 'gradletest'
let test#scala#runner = 'sbttest'
let g:test#javascript#runner = 'jest'

" CONQUER OF COMPLETION
" ---- --
" Extensions
let g:coc_global_extensions = [
  \ 'coc-tsserver',
  \ 'coc-json',
  \ 'coc-java',
  \ 'coc-go',
  \ 'coc-pyright',
  \ 'coc-eslint',
  \ 'coc-vetur',
  \ 'coc-css'
  \ ]
let g:coc_node_path = '/opt/homebrew/bin/node'
" TextEdit might fail if hidden is not set.
set hidden

" Some servers have issues with backup files
set nobackup nowritebackup

" Give more space for displaying messages.
set cmdheight=2

" Having longer updatetime (default is 4000 ms = 4 s) leads to noticeable
" delays and poor user experience.
set updatetime=300

" Don't pass messages to |ins-completion-menu|.
set shortmess+=c

" Always show the signcolumn, otherwise it would shift the text each time
" diagnostics appear/become resolved.
set signcolumn=number

" Use tab for trigger completion with characters ahead and navigate.
" NOTE: Use command ':verbose imap <tab>' to make sure tab is not mapped by
" other plugin before putting this into your config.
inoremap <silent><expr> <TAB>
      \ pumvisible() ? "\<C-n>" :
      \ <SID>check_back_space() ? "\<TAB>" :
      \ coc#refresh()
inoremap <expr><S-TAB> pumvisible() ? "\<C-p>" : "\<C-h>"

function! s:check_back_space() abort
  let col = col('.') - 1
  return !col || getline('.')[col - 1]  =~# '\s'
endfunction

" Use <c-tab> to trigger completion.
inoremap <silent><expr> <c-tab> coc#refresh()

" Use <cr> to confirm completion, `<C-g>u` means break undo chain at current
" position. Coc only does snippet and additional edit on confirm.
" <cr> could be remapped by other vim plugin, try `:verbose imap <CR>`.
if exists('*complete_info')
  inoremap <expr> <cr> complete_info()["selected"] != "-1" ? "\<C-y>" : "\<C-g>u\<CR>"
else
  inoremap <expr> <cr> pumvisible() ? "\<C-y>" : "\<C-g>u\<CR>"
endif

" Remap keys for applying codeAction to the current buffer.
nmap <silent><leader>ac  <Plug>(coc-codeaction)
" Apply AutoFix to problem on the current line.
nmap <silent><leader>qf  <Plug>(coc-fix-current)

" Symbol renaming.
nmap <leader>rn <Plug>(coc-rename)

" GoTo code navigation.
nmap <leader>gd <Plug>(coc-definition)
nmap <leader>gy <Plug>(coc-type-definition)
nmap <leader>gi <Plug>(coc-implementation)
nmap <leader>gr <Plug>(coc-references)
nnoremap <silent> <leader>h :call CocActionAsync('doHover')<cr>

nmap <expr> <silent> <leader>sd <SID>select_current_word()
function! s:select_current_word()
  if !get(b:, 'coc_cursors_activated', 0)
    return "\<Plug>(coc-cursors-word)"
  endif
  return "*\<Plug>(coc-cursors-word):nohlsearch\<CR>"
endfunc

" REPL
" ---- --
let g:repl_program = {
            \   'python': 'python3',
            \   'default': 'zsh',
            \   'javascript': 'node',
            \   'scala': 'scala',
            \   }
let g:repl_exit_commands = {
			\	'node': '.exit',
			\	'scala': ':quit',
			\	}
let g:repl_console_name = 'SÃ¤lem, Ã„lem!'
let g:repl_python_automerge = 1
let g:repl_output_copy_to_register = "t"
let g:sendtorepl_invoke_key = "<leader>ee"
let g:repl_position = 3
nnoremap <leader>re :REPLToggle<cr>
nnoremap <leader>er {v}:SendLineToREPL<cr>


set noshowmode
filetype plugin indent on
syntax enable
highlight Normal guibg=NONE ctermbg=NONE


" MacOS Yank
" Sends default register to terminal TTY using OSC 52 escape sequence
function! Osc52Yank()
    let buffer=system('base64 | tr -d "\n"', @0)
    let buffer='\033]52;c;'.buffer.'\033\'
    silent exe "!echo -ne ".shellescape(buffer).
        \ " > ".(exists('g:tty') ? shellescape(g:tty) : '/dev/tty')
endfunction

" Like Osc52Yank, except send all the contents to a single line
function! Osc52YankOneLine()
  let @"=substitute(@", '\n', '', 'g')
  call Osc52Yank() | redraw!
endfunction

" Automatically call OSC52 function on yank to sync register with host clipboard
augroup Yank
  autocmd!
  autocmd TextYankPost * if v:event.operator ==# 'y' | call Osc52Yank() | endif
augroup END

" Statusline
" ---- --
highlight YellowOnBlue guibg=#00afca guifg=#fec50c
highlight WhiteOnPurple guibg=#483162 guifg=White
highlight PurpleOnWhite guibg=White   guifg=#483162 gui=Bold

" default statusline when entering Vim
highlight StatusLine guibg=#483162 guifg=White 
highlight StatusLineNC guibg=NONE guifg=White

" Formats the statusline
let g:currentmode={
       \ 'n'  : 'N',
       \ 'v'  : 'V',
       \ 'V'  : 'V',
       \ "\<C-V>" : 'V',
       \ 'i'  : 'I',
       \ 'r'  : 'R',
       \ 'R'  : 'R',
       \ 'Rv' : 'V',
       \ 'c'  : 'C',
       \ 's'  : 'S',
       \ 't'  : 'T',
       \}

function! SpocklineActive()
    let result = ""

    if &filetype ==? "netrw"
        let result .= " %F "
    else
        let branch = FugitiveHead()
        let l:mode = g:currentmode[mode()]

        if l:mode ==? "I" || l:mode ==? "C"
            let result .= "%#YellowOnBlue#"
        else
            if strlen(branch) > 0
                let result .= "%#PurpleOnWhite#"
            else
                let result .= "%#WhiteOnPurple#"
            endif
        endif
        let result .= " " . l:mode . " %*"

        if strlen(branch) > 0
            let result .= " " . branch . " "
        endif

        let result .= "%#PurpleOnWhite# %t %*"   "file name
        let result .= "%m"                       "modified flag

        let result .= "%="                       "align right
        let result .= "%#PurpleOnWhite#%y%*"     "file type
        let result .= " %3.3p%% "                "line X of Y [percent of file]
        let result .= " ðŸ–– "
    endif

    return result
endfunction

function! SpocklineInactive()
    let result = ""

    let result .= " %f "   "file name
    let result .= "%m"     "modified flag

    let result .= "%="     "align right
    let result .= " ðŸ¤¨ "

    return result
endfunction

augroup Spockline
    autocmd!
    autocmd WinEnter * setlocal statusline=%!SpocklineActive()
    autocmd WinLeave * setlocal statusline=%!SpocklineInactive()
augroup END

set statusline=%!SpocklineActive()


let g:codi#interpreters = {
   \ 'python': {
       \ 'bin': 'python3',
       \ 'prompt': '^\(>>>\|\.\.\.\) ',
       \ },
   \ }
